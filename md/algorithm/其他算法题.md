# 其他算法题

[学习算法参考文档](https://xiaochen1024.com/courseware/60b4f11ab1aa91002eb53b18/60b4f191b1aa91002eb53b1a)
## 一、相关的一些解题思路

+ 回溯 
  + [传送门](../algorith/../algorithm/回溯算法.md)
+ 深度优先遍历
  + [回溯法与深度优先搜索的关系](https://www.cnblogs.com/tflsnoi/p/13689806.html)
  + 可以理解为：**回溯法就是深度优先搜索的一种控制策略**
+ 广度优先遍历
+ 递归
+ 滑动窗口
+ 贪心算法
+ 二叉树、四叉树
+ 二分法
+ 哈希表 new Map()
+ 动态规划
+ 循环遍历 (for、 while)
+ 堆、栈思想
+ 记忆化搜索


## 二、思路对应的典型列子

###   记忆化搜索

   ```javascript
    //  解题方案 深度优先遍历 + 记忆化搜索 
    // 题目 
    // 给你一个字符串 s 和一个字符串列表 wordDict 作为字典。请你判断是否可以利用字典中出现的单词拼接出 s 。
    // 注意：不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。

    // 输入: s = "leetcode", wordDict = ["leet", "code"]
    // 输出: true
    // 解释: 返回 true 因为 "leetcode" 可以由 "leet" 和 "code" 拼接成。
    // 引用链接 https://leetcode-cn.com/problems/word-break/solution/shou-hui-tu-jie-san-chong-fang-fa-dfs-bfs-dong-tai/
      const wordBreak = (s, wordDict) => {
        const len = s.length;
        const wordSet = new Set(wordDict);
        const memo = new Array(len); //存储记忆 避免重复计算，尤其是在深度优先遍历的场景中，会有明显的性能改善

        const canBreak = (start) => {//判断从start到末尾的子串能否break
          if (start == len) return true; //指针越界 , 结束递归
          if (memo[start] !== undefined) return memo[start]; // memo中有，就用memo中的

          for (let i = start + 1; i <= len; i++) {
            const prefix = s.slice(start, i);
            if (wordSet.has(prefix) && canBreak(i)) { //wordSet.has(prefix)可以理解为回溯的枝剪 ，当不满足的时候不会进行进一步的canBreak
              memo[start] = true; // 当前递归的结果存一下 
              return true;
            }
          }
          memo[start] = false; // 当前递归的结果存一下 
          return false;
        };
        return canBreak(0);
      };
      // 加了记忆化搜索后可以快速应对下面的参数
      // "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab,["a","aa","aaa","aaaa","aaaaa","aaaaaa","aaaaaaa","aaaaaaaa","aaaaaaaaa","aaaaaaaaaa"]


   ```

 ### 动态规划

 #### 1、基础概念

  动态规划，英文：Dynamic Programming，简称DP，将问题分解为**互相重叠的子问题**，通过**反复求解子问题**来解决原问题就是动态规划，如果某一问题有很多重叠子问题，使用动态规划来解是比较有效的。

**三个重要点**需要记住

- 重叠子问题
- 最优子结构
- 状态转移方程

**动态规划解题思路/步骤**

1. 定义子问题

2. 实现要反复执行而解决子问题的部分/即状态转移方程: 

3. 识别并求解出边界条件:

#### 2、题目解析

+ 力扣题 [122. 买卖股票的最佳时机 II](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/)

    解析思路步骤

1.  **定义子问题** ：  当天交易结束是否只有股票 两种情况：①持有（前一天就持有，今天继续持有\ 前一天没持有，今天购买） ②未持有（前一天未持有,今天不操作\前一天持有，今天卖了） 定义 dp[i][0]：第i天结束未持有  dp[i][1]：第i天结束持有股票

2. **实现要反复执行而解决子问题的部分/即状态转移方程**:  dp[i][0] = Math.max(dp[i-1][0] , dp[i-1][1]+ price[i]) 以及 dp[i][1] = Math.max(dp[i-1][1],dp[i-1][0] - price[i])

3. **识别并求解出边界条件**:  

```javascript
    // 题目
    var maxProfit = function(prices) {
      let len = prices.length
      let dp = new Array(len).fill(0).map(res=> new Array(2).fill(0))
      dp[0][0] = 0
      dp[0][1] = - prices[0] 
      for(let i = 1; i<len ; i++){
          dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1]+ prices[i])
          dp[i][1] = Math.max(dp[i-1][1], dp[i-1][0] - prices[i])   
      }
      return dp[len - 1][0]
  };
```

+ 背包01问题

     求n个物品，重量，价值分别是wArr[i],vArr[i],放入容量为b的书包，最大价值


 解析思路步骤

1.  **定义子问题** ：  每个物品都有两种状态：拿\不拿  定义：dp[i][j] i个物品空间为j时最大的价值

2. **实现要反复执行而解决子问题的部分/即状态转移方程**:  dp[i][j] = Max(dp[i-1][j],dp[i-1][j-w[i]]+v[i]) //dp[i-1][j]不拿  dp[i-1][j-w[i]]+v[i]//拿

3. **识别并求解出边界条件**: j<w[i]

```javascript
let wArr = [1,5,3,6] ,vArr= [2,3,4,5] ,b = 9

function fn() {
    let dp = [[]]
    let len = wArr.length
    for(let i = 1; i< len; i++){
        dp[i] = []
        for(let j = 0 ;j<=b; j++ ){
           if(i===1){
                  dp[0][j] = wArr[0] > j ? 0:vArr[0]
              }
              if(j<wArr[i]){
                  dp[i][j] = dp[i-1][j]
              }else {
                  dp[i][j] = Math.max(dp[i-1][j],dp[i-1][j-wArr[i]]+vArr[i])
              }

        }
    }
     return dp[len-1][9]
}
 fn()
```

+ 不同路径问题 [题目地址](https://leetcode.cn/problems/unique-paths/)