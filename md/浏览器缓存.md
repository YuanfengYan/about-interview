# 浏览器缓存
## 基础概念：

  [缓存存在那些位置？缓存位置可分Service Worker、Memory Cache、Disk Cache、Push Cache四种](https://blog.csdn.net/m0_37217612/article/details/107942864)

    很多时候，大家倾向于将浏览器缓存简单地理解为“HTTP 缓存”。但事实上，浏览器缓存机制有四个方面，它们按照获取资源时请求的优先级依次排列如下

  - 1 Service Worker -- Service Worker 是运行在浏览器背后的独立线程，传输协议必须为 HTTPS [浏览器缓存之http缓存和service worker](https://blog.csdn.net/u010674395/article/details/106981924/)

  - 2 Memory Cache 内存

  - 3 Disk Cache 硬件

  - 4 Push Cache

====
====


+ HTTP链上的缓存系统，我们一般指浏览器的缓存系统，和代理服务器的缓存。

+ HTTP协议的Cache -Control指定请求和响应遵循的缓存机制。在请求消息或响应消息中设置 Cache-Control并不会影响另一个消息处理过程中的缓存处理过程。

  >即比如：前端请求头中也可以修改Cache-Control以表达前端应用中希望的缓存策略，即可以强制绕过浏览器缓存，直接请求服务器上的最新资源。但这并不一定影响相应头中的Cache-Control。

## 关于cache-control是出现在response还是request的区别

### cache-control出现在request中：

+ cache-control:no-cache 告诉HTTP消息链上的缓存系统(也就是浏览器的缓存和代理服务器上的缓存)，本次请求要求忽略一齐缓存，必须是原始服务器重新计算生成回应给用户。所以，即使浏览器上的本地缓存未过期，或者代理服务器上的缓存未过期，都不要将这些缓存作为回应。当我们在浏览器中强制刷新页面（按ctrl+F5），发送的就是这个头（不同很多浏览器将cache-contro:no-cachel和pragam:no-cache两个头一起发送）

+ pragma:no-cache：和cache-control:no-cache一样，不过出于兼容HTTP/1.0，所以有些浏览器会保留这个头。注意pragma:no-cache只应该出现在Request中，表明不想获取缓存。HTTP没有哪条条文对Response中的pragma:no-cache进行定义，所以Response中的pragma:no-cache是无效的。

### cache-control出现在response中:

+ cache-control:no-control 服务器告诉HTTP消息链上的缓存系统，不要缓存这个response结果。其实这个不是百分百肯定，而且不同浏览器好像接收到这个头时也有不同反应。

### 其他

    未找到取证

而另外，cache-control：no-store出现在response中才有意义，意思是告诉缓存系统不要缓存或者存储response内容（不要任何形式的存储，包括存储在缓存文件夹中，以免一些敏感信息外泄）。chrome,IE9,FF对这个头的实现是一样的。当接收到有这个头的response，三个浏览器的缓存目录都找不到相关的缓存文件。
  
  

## 一、强制缓存

>其实强是强制的意思。当浏览器去请求某个文件的时候，服务端就在respone header里面对该文件做了缓存配置。缓存的时间、缓存类型都由服务端控制

### cache-control

+ cache-control: max-age=xxxx，public  
客户端和代理服务器都可以缓存该资源；
客户端在xxx秒的有效期内，如果有请求该资源的需求的话就直接读取缓存,statu code:200 ，如果用户做了刷新操作，就向服务器发起http请求

+ cache-control: max-age=xxxx，private  
只让客户端可以缓存该资源；代理服务器不缓存
客户端在xxx秒内直接读取缓存,statu code:200

+ cache-control: max-age=xxxx，immutable  
客户端在xxx秒的有效期内，如果有请求该资源的需求的话就直接读取缓存,statu code:200 ，即使用户做了刷新操作，也不向服务器发起http请求

+ cache-control: no-cache  
跳过设置强缓存，但是不妨碍设置协商缓存；一般如果你做了强缓存，只有在强缓存失效了才走协商缓存的，设置了no-cache就不会走强缓存了，每次请求都回询问服务端。

+ cache-control: no-store  
不缓存，这个会让客户端、服务器都不缓存，也就没有所谓的强缓存、协商缓存了。

### Expires 

>优先级较cache-control低一点

时间是服务器绝对时间

## 二、协商缓存

  ETag的优先级比Last-Modified高

### last-modified if-modified-since

优点：耗费资源少
缺点：Last-Modified的精度只能到秒，如果一个资源频繁修改，在同一秒进行多次修改，你从Last-Modified上是看不出来区别的

#### 对应的在提交时使用的：

  If-Unmodified-Since
### etag if-none-matched

优点：他比Last-Modified精度高，更准确。
缺点：你的ETag如果设计为一个hash值，每次请求都要计算这个值，需要额外耗费服务器资源。

  服务端拿到客户端请求里面的If-None-Match跟当前版本的ETag比较下：

  >如果是一样的话，直接返回304，语义为Not Modified，不返回内容(body)，只返回header，告诉浏览器直接用缓存
  >如果不一样的话，返回200和最新的内容

#### 对应的在提交时使用的：

  request header----If-Match
  if-Match通常用于post或者put请求中
  如果已经提交过了，If-Match就不成立了，这时候服务端会给你返回412错误，也就是Precondition Failed，前提条件失败。

## 三 200 or 304

在没有设置Cache-Control的情况下，设置Last-Modified和ETag缓存，会出现200（from cache）和304 交替出现的情况

设置Cache-Control的情况下，过期刷新会出现304(如果有更新内容，则是200)，之后再过期之前刷新都是200（from cache）。如果要确保要向服务端确认，可以将Cache-Contral的max-age设置为0。
## 参考文档

+ [彻底弄懂强缓存与协商缓存](https://www.jianshu.com/p/9c95db596df5)
+ 👍 [轻松理解HTTP缓存策略](https://blog.csdn.net/dennis_jiang/article/details/111589275))
+ [request的cache-control和response cache-control不同点](https://blog.csdn.net/weixin_34221036/article/details/92032569)
+ [浅谈http中的Cache-Control](https://blog.csdn.net/u012375924/article/details/82806617)