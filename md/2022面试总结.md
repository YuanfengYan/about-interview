<!--
 * @Description: 
 * @Author: yanyuanfeng
 * @Date: 2022-07-06 15:18:14
 * @LastEditors: yanyuanfeng
 * @LastEditTime: 2022-08-02 14:49:48
-->
# 总结

## Vue

基础的vue使用需要了解
### 1. 如何去扩展现有组件？

逻辑扩展: mixins、 extends、 composition api

内容扩展： slots

### 2. 如何制作vue插件？ 以及vue2和3有什么写法区别

    首先vue插件功能分类：

  - 添加全局方法或者 property。如：vue-custom-element

  - 添加全局资源：指令/过渡等。如：vue-touch）

  - 通过全局 mixin 来添加一些组件选项。(如vue-router)

  - 添加全局实例方法，通过把它们添加到 config.globalProperties 上实现。

  - 一个库，提供自己的 API，同时提供上面提到的一个或多个功能。如 vue-router

区别：

    use(plugin)自动调用install函数时
    vue2: 自动传入Vue实例
    vue3: 自动传入App应用实例

    定义全局访问
    vue2: Vue.prototype.$plugin
    vue3: app.config.globalProperties.$plugin

    挂载组件
    vue2: Vue.extend(plugin) + 构造器实例化 + 挂载
    vue3: createApp(plugin) + 挂载



vue2

```javascript
MyPlugin.install = function (Vue, options) {
  // 1. 添加全局方法或属性
  Vue.myGlobalMethod = function () {
    // 逻辑...
  }

  // 2. 添加全局资源
  Vue.directive('my-directive', {
    bind (el, binding, vnode, oldVnode) {
      // 逻辑...
    }
    ...
  })

  // 3. 注入组件
  Vue.mixin({
    created: function () {
      // 逻辑...
    }
    ...
  })

  // 4. 添加实例方法
  Vue.prototype.$myMethod = function (methodOptions) {
    // 逻辑...
  }
}
// 调用 `MyPlugin.install(Vue)`
Vue.use(MyPlugin)

new Vue({
  //... options
})

```

vue3

```javascript
MyPlugin.install = function (app, options) {
  // 2. 添加全局资源 指令
  app.directive('my-directive', {
    // 在绑定元素的 attribute 或事件监听器被应用之前调用
    created(...arg) {
      console.log(arg)
    },
    // 在绑定元素的父组件挂载之前调用
    beforeMount() {},
    // 在绑定元素的父组件挂载之后调用
    mounted(el,binding,vnode) {
    },
    // 在包含组件的 VNode 更新之前调用
    beforeUpdate() {},
    // 在包含组件的 VNode 及其子组件的 VNode 更新之后调用
    updated() {},
    // 在绑定元素的父组件卸载之前调用
    beforeUnmount() {},
    // 在绑定元素的父组件卸载之后调用
    unmounted() {}
    })
  })
  //3、定义全局
  app.config.globalProperties.$plugin = instance;
}

```

### 3. VUE的生命周期及理解？

  总共分为8个阶段，具体为：创建前/后，载入前/后，更新前/后，销毁前/后。

  - 创建前/后： 在beforeCreated阶段：vue实例的挂载元素$el和数据对象data都为undefined，还未初始化；在created阶段，vue实例的数据对象data有了，$el还没有。
  - 载入前/后：在beforeMount阶段，vue实例的$el和data都初始化了，但还是挂载之前为虚拟的dom节点，data.message还未替换；在mounted阶段，vue实例挂载完成，data.message成功渲染。
  - 更新前/后：当data变化时，会触发beforeUpdate和updated方法。
  - 销毁前/后：在执行destroy方法后，对data的改变不会再触发周期函数，说明此时vue实例已经解除了事件监听以及和dom的绑定，但是dom结构依然存在。

### 4. vue的自定义指令？

### 5. vue的diff算法理解？

### 6. vue组件的通信

### 7. vue的keep-alive的理解？

- [vue中keep-alive的原理](https://blog.csdn.net/qq_42072086/article/details/110820930)
- [vue--官网keep-alive](https://v3.cn.vuejs.org/api/built-in-components.html#keep-alive)

### 8. computed和watch的用法和区别？

### 9. 插槽使用<slot> v-slot #default 

- 带有插槽的组件在父组件中使用，如何拿到该组件里的值==》例如：在改组件中的slot标签定义属性值 item="xxx"，在父组件中使用时 <template v-slot:default="defaultSlot" / > 然后在对应template标签下使用defaultSlot.item这个值

- 上一条中defaultSlot也可以解构slot中的属性值 <template v-slot:default="{item}" / > 或者别名 <template v-slot:default="{item:todo}" / > 或者缩写 <template #default="{item}" / >


### 10. 性能优化方案

- v-memo v-once
- v-if/ v-show
- keep-alive 使常用组件进行缓存，减少组件创建与卸载，提高响应速度与资源利用

```javascript
<KeepAlive :include="/a|b/"> <!-- 表示仅缓存name为a或b的组件 -->
  <component :is="view" />
</KeepAlive>

```
- provide和inject 如果可以 代替 Vuex
- 善用异步加载 defineAsyncComponent

```javascript
import { defineAsyncComponent } from 'vue'

export default {
  // ...
  components: {
    AsyncComponent: defineAsyncComponent(() =>
      import('./components/AsyncComponent.vue')
    )
  }
}

```

- 列表虚拟化 [vue-virtual-scroller](https://github.com/Akryum/vue-virtual-scroller)、[vue-virtual-scroll-grid](https://github.com/rocwang/vue-virtual-scroll-grid)。

- toRaw 做一些不想被监听的事情(提升性能)

- 仅传递必要的数据

- 减少大型不可变结构的反应性开销，灵活运用shallowRef()和shallowReactive()来创建浅反应式数据。

- 避免内存泄漏
  - 避免意外的全局变量
  - 避免使用不当的闭包
  - 及时清除定时器与不用的数据，一般会在unMounted中执行


[参考文档-Vue性能优化方案——个人经验总结](https://blog.csdn.net/qq_41176306/article/details/124650401)
### 11. reactive和ref的区别 以及对应的 shallowRef 与shallowReactive （创建非递归响应对象）

[参考文档-Vue3.0中Ref与Reactive的区别是什么](https://www.yisu.com/zixun/604877.html)

1. Ref的本质是通过Reactive创建的，Ref(10)=>Reactive({value:10});

2. Reactive的本质是将每一层的数都解析成proxy对象，Reactive 的响应式默认都是递归的，改变某一层的值都会递归的调用一遍，重新渲染dom。

3. ref和reactive都为递归监听

4. Ref的本质是通过Reactive创建的，Ref(10)=>Reactive({value:10});

+ shallowRef与shallowReactive

1. shallowRef 与shallowReactive创建的是非递归的响应对象，shallowReactive创建的数据第一层数据改变会重新渲染dom

2. 通过shallowRef创建的响应式对象，需要修改整个value才能重新渲染dom

```javascript
var state = shallowRef({
   a:'a',
    gf:{
       b:'b',
       f:{
          c:'c',
          s:{d:'d'}
       }
    }
})
state.value.a = 1//并不能重新渲染，shallowRef的原理也是通过shallowReactive({value:{}})创建的，要修改value才能重新渲染
// 方案一
state.value = {
    a:'1',
    gf:{
       b:'2',
       f:{
          c:'3',
          s:{d:'d'}
       }
    }
}
// 方案二
state.value.a = 1
triggerRef(state)

```

### 12 toRef、toRefs、toRaw

1. toRef、toRefs 

作用/场景：

  toRef 和 toRefs 可以用来复制 reactive 里面的属性然后转成 ref，而且它既保留了响应式，也保留了引用，也就是你从 reactive 复制过来的属性进行修改后，除了视图会更新，原有 ractive 里面对应的值也会跟着更新，如果你知道 浅拷贝 的话那么这个引用就很好理解了，它复制的其实就是引用 + 响应式 ref

  可以封装函数返回响应式属性，对象。可以理解为浅拷贝引用。

- [Vue3 理解 toRef 和 toRefs 的作用、用法、区别](https://blog.csdn.net/cookcyq__/article/details/121618833)
  
2. toRaw

- toRaw
 	从Reactive或Ref中得到原始数据

  返回 reactive 或 readonly 代理的原始对象。这是一个“逃生舱”，可用于临时读取数据而无需承担代理访问/跟踪的开销，也可用于写入数据而避免触发更改。不建议保留对原始对象的持久引用。请谨慎使用。

  
- toRaw作用
 	做一些不想被监听的事情(提升性能)

  如在搜索框中,绑定了有个响应式变量searchValue,但是有个请求数据的方法不需要该变量的代理跟踪访问,这么在输入框输入该值时,不会一直触发该请求方法,直到点击按钮,才触发该方法


[参考文档-Vue3.0 toRaw函数和markRaw函数](https://www.jianshu.com/p/73fcbbc9b654)

### 13 vue3相关的api 清单

1. 7个应用配置：errorHandler， warnHandler（只在开发环境）， globalProperties， optionMergeStrategies， performance， compilerOptions ，~~isCustomElement~~
2. 9个应用api: component, config, directive, mixin, mount ,provide, unmount, use , version
3. 14个全局api: createApp, h , defineComponent, defineAsyncComponent, defineCustomElement ,resolveComponent, resolveDynamicComponent,resolveDirective,withDirectives, createRenderer, nextTick, mergeProps, useCssModule, version
4. 选项：
   1. 7个Data选项：data,props,computed,methods,watch.emits,expose
   2. 2个Dom选项： template render
   3. 13个生命周期：2*（created,mounted,updated,unmounted）,actived, deactived,errorCaptured,renderTracked,renderTriggered,
   4. 2个选项/资源：components, directive
   5. 4个组合：mixins, extends,provide/inject, setup
   6. 3个杂项：name,inheritAttrs,complierOptions 
5. 9个实例属性：$data, $props, $el,$options,$praent,$root,$refs,$slots,$attrs
6. 4个实例方法：$watch , $emit , $forceUpdate , $nextTick
7. 15个指令
8. 3个特殊attribute: ref key is
9. 6个内置组件：component , transition , transition-group , keep-alive , slot, teleport
10. 响应性api
   1. 9个响应性基础api: ractive，readonly, isProxy , isReactive, isReadonly, toRaw, markRaw, shallowReactive, shallowReadyonly
   2. 8个Refs: ref, unref, toRef, toRefs, isRef, customRef, shallowRef, triggerRef
   3. 5个Computed与Watch:computed , watchEffect, watchPostEffect , watchSyncEffect, watch
   4. 3个Effect作用域API:用于库开发
11. 组合式API
    1. setup
    2. 生命周期钩子 OnX
    3. Provide / Inject
    4. getCurrentInstance

### 14 vu2Api 清单 以及和Vue3比较变更

1. 9个全局配置 : 移除 ：silent devtools keyCodes productionTip 保留：optionMergeStrategies errorHandler  warnHandler performance q迁移：Vue.config.ignoredElements=》app.config.compilerOptions.isCustomElement
2. 12个全局 API：移除 Vue.extend Vue.set Vue.delete Vue.filter Vue.commplie Vue.observable 迁移至应用Api： nextTick directive mixin use component version
3. 选项
   1. 6个Data选项：data props computed methods watch . 移除： propsData
   2. 3个Dom选项： template render 。 移除：el renderError
   3. 11个生命周期：都保留只是destory =>unmounted。 v3新增： renderTracked,renderTriggered
   4. 3个选项/资源：directives components ； 移除： filters
   5. 4个选项/组合: mixins extends provide/inject 移除：praent  v3新增：setup
   6. 6个杂项： name inheritAttrs 移除：delimiters（用compilerOptions.delimiters替换） functional model comments (app.config.compilerOptions.comments)
4. 14个实例属性：$data, $props, $el,$options,$praent,$root,$refs,$slots,$attrs  移除：$children $scopedSlots $isServer $listeners
5. 11个实例方法： $watch  $emit , $forceUpdate , $nextTick  移除 ：$on，$off  $once $delete  $mount  $set
6. 14个指令： v3新增：v-memo 移除: v-is
7. 6个特殊attribute: key ref is 移除：slot  slot-scope   scope
8. 5个内置的组件： component  transition  transition-group  keep-alive  slot  v3新增： teleport

### 15. VUE3中watch与watchEffect

watch与 watchEffect 比较允许我们：

- 懒执行副作用；
- 更具体地说明什么状态应该触发侦听器重新运行；
- 访问侦听状态变化前后的值。

watchEffect的一些特点：

- 不需要手动传入依赖（不用指定监听对象）
- 无法获取原始值，只能获取更新后的值
- 立即执行（在onMounted前调用）
- 一些异步操作放里面更加的合适

功能： 
1. 停止监听
2. 更改监听时机：
```javascript
  watchEffect(() => {
   console.log(count.value)
},{flush:"pre"}) //pre, post, sync
```
3. 清除副作用 onInvalidate
```javascript
  watchEffect((onInvalidate) => {
   console.log(count.value)
   onInvalidate(()=>{
      //会在重新运行时或者停止时先执行
      // 可以用来取消一些异步请求事件
   })
},{flush:"pre"}) //pre, post, sync
```
4. 侦听器调试 onTrack 和 onTrigger 选项可用于调试侦听器的行为。



[参考文档-VUE3中watch与watchEffect](https://blog.csdn.net/m0_51969330/article/details/123673334)

## 参考文档
[el x修改激活的菜单_Vue3.0文档 VS Vue2.x文档 有哪些不同](https://blog.csdn.net/weixin_35831256/article/details/112166478)
[vue2 面试](https://zhuanlan.zhihu.com/p/388256334)